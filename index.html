<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Fixed Tree Layout with Pan/Zoom</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars for pan/zoom */
            font-family: Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }

        #app-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
            cursor: grab;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(9, 120px); /* 9 columns */
            grid-template-rows: repeat(6, 100px);   /* 6 rows */
            gap: 10px; /* Reduced gap for more compact layout */
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: absolute;
            transform-origin: center center;
            /* Center the grid container initially */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .card {
            background-color: #e0f2f7; /* Light blue */
            border: 1px solid #b3e5fc; /* Slightly darker blue border */
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 0.8em; /* Slightly smaller font for more text */
            color: #01579b; /* Dark blue text */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: transform 0.1s ease-out;
            padding: 5px; /* Add padding inside cards for text wrapping */
            word-wrap: break-word; /* Ensure long words break */
            white-space: normal; /* Allow text to wrap */
            line-height: 1.2; /* Adjust line height for two lines */
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* Fixed Grid Positions for 40 Cards (9x6 grid) */
        /* Note: User's Y coordinates are reversed for CSS grid-row (6 is top, 1 is bottom) */
        /* Level 1 (1 card) */
        #card-L1-1 { grid-column: 5; grid-row: 1; } /* User (5, 6) */

        /* Level 2 (3 cards) */
        #card-L2-1 { grid-column: 2; grid-row: 2; } /* User (2, 5) */
        #card-L2-2 { grid-column: 5; grid-row: 2; } /* User (5, 5) */
        #card-L2-3 { grid-column: 8; grid-row: 2; } /* User (8, 5) */

        /* Level 3 (9 cards) */
        /* From card-L2-1 */
        #card-L3-1 { grid-column: 1; grid-row: 3; } /* User (1, 4) */
        #card-L3-2 { grid-column: 2; grid-row: 3; } /* User (2, 4) */
        #card-L3-3 { grid-column: 3; grid-row: 3; } /* User (3, 4) */
        /* From card-L2-2 */
        #card-L3-4 { grid-column: 4; grid-row: 3; } /* User (4, 4) */
        #card-L3-5 { grid-column: 5; grid-row: 3; } /* User (5, 4) */
        #card-L3-6 { grid-column: 6; grid-row: 3; } /* User (6, 4) */
        /* From card-L2-3 */
        #card-L3-7 { grid-column: 7; grid-row: 3; } /* User (7, 4) */
        #card-L3-8 { grid-column: 8; grid-row: 3; } /* User (8, 4) */
        #card-L3-9 { grid-column: 9; grid-row: 3; } /* User (9, 4) */

        /* Level 4 (27 cards) - 3 vertical children for each L3 card */
        /* Children of card-L3-1 (1, 3) */
        #card-L4-1  { grid-column: 1; grid-row: 4; } /* User (1, 3) */
        #card-L4-2  { grid-column: 1; grid-row: 5; } /* User (1, 2) */
        #card-L4-3  { grid-column: 1; grid-row: 6; } /* User (1, 1) */
        /* Children of card-L3-2 (2, 3) */
        #card-L4-4  { grid-column: 2; grid-row: 4; } /* User (2, 3) */
        #card-L4-5  { grid-column: 2; grid-row: 5; } /* User (2, 2) */
        #card-L4-6  { grid-column: 2; grid-row: 6; } /* User (2, 1) */
        /* Children of card-L3-3 (3, 3) */
        #card-L4-7  { grid-column: 3; grid-row: 4; } /* User (3, 3) */
        #card-L4-8  { grid-column: 3; grid-row: 5; } /* User (3, 2) */
        #card-L4-9  { grid-column: 3; grid-row: 6; } /* User (3, 1) */
        /* Children of card-L3-4 (4, 3) */
        #card-L4-10 { grid-column: 4; grid-row: 4; } /* User (4, 3) */
        #card-L4-11 { grid-column: 4; grid-row: 5; } /* User (4, 2) */
        #card-L4-12 { grid-column: 4; grid-row: 6; } /* User (4, 1) */
        /* Children of card-L3-5 (5, 3) */
        #card-L4-13 { grid-column: 5; grid-row: 4; } /* User (5, 3) */
        #card-L4-14 { grid-column: 5; grid-row: 5; } /* User (5, 2) */
        #card-L4-15 { grid-column: 5; grid-row: 6; } /* User (5, 1) */
        /* Children of card-L3-6 (6, 3) */
        #card-L4-16 { grid-column: 6; grid-row: 4; } /* User (6, 3) */
        #card-L4-17 { grid-column: 6; grid-row: 5; } /* User (6, 2) */
        #card-L4-18 { grid-column: 6; grid-row: 6; } /* User (6, 1) */
        /* Children of card-L3-7 (7, 3) */
        #card-L4-19 { grid-column: 7; grid-row: 4; } /* User (7, 3) */
        #card-L4-20 { grid-column: 7; grid-row: 5; } /* User (7, 2) */
        #card-L4-21 { grid-column: 7; grid-row: 6; } /* User (7, 1) */
        /* Children of card-L3-8 (8, 3) */
        #card-L4-22 { grid-column: 8; grid-row: 4; } /* User (8, 3) */
        #card-L4-23 { grid-column: 8; grid-row: 5; } /* User (8, 2) */
        #card-L4-24 { grid-column: 8; grid-row: 6; } /* User (8, 1) */
        /* Children of card-L3-9 (9, 3) */
        #card-L4-25 { grid-column: 9; grid-row: 4; } /* User (9, 3) */
        #card-L4-26 { grid-column: 9; grid-row: 5; } /* User (9, 2) */
        #card-L4-27 { grid-column: 9; grid-row: 6; } /* User (9, 1) */

        /* Responsive Design Adjustments */
        @media (max-width: 1024px) {
            #grid-container {
                grid-template-columns: repeat(9, 80px); /* Smaller columns */
                grid-template-rows: repeat(6, 80px); /* Smaller rows */
                gap: 8px;
            }
            .card {
                font-size: 0.7em;
                padding: 3px;
            }
        }

        @media (max-width: 768px) {
            #grid-container {
                grid-template-columns: repeat(9, 60px); /* Even smaller columns */
                grid-template-rows: repeat(6, 60px); /* Even smaller rows */
                gap: 5px;
                padding: 10px;
            }
            .card {
                font-size: 0.6em;
                padding: 2px;
            }
            #app-container {
                touch-action: none; /* Ensure pan/zoom is smooth on touch devices */
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="grid-container">
            <!-- Cards will be dynamically inserted here by JavaScript -->
        </div>
    </div>

    <script>
        // Dummy cardsData with 40 cards based on the new 9x6 grid structure
        const cardsData = [
            { "id": "card-L1-1", "level": 1, "text": "Start Node Main Card" },
            // Level 2 (3 cards)
            { "id": "card-L2-1", "level": 2, "text": "Second Level Card A" },
            { "id": "card-L2-2", "level": 2, "text": "Second Level Card B" },
            { "id": "card-L2-3", "level": 2, "text": "Second Level Card C" },
            // Level 3 (9 cards)
            { "id": "card-L3-1", "level": 3, "text": "Third Level Node 1-1" },
            { "id": "card-L3-2", "level": 3, "text": "Third Level Node 1-2" },
            { "id": "card-L3-3", "level": 3, "text": "Third Level Node 1-3" },
            { "id": "card-L3-4", "level": 3, "text": "Third Level Node 2-1" },
            { "id": "card-L3-5", "level": 3, "text": "Third Level Node 2-2" },
            { "id": "card-L3-6", "level": 3, "text": "Third Level Node 2-3" },
            { "id": "card-L3-7", "level": 3, "text": "Third Level Node 3-1" },
            { "id": "card-L3-8", "level": 3, "text": "Third Level Node 3-2" },
            { "id": "card-L3-9", "level": 3, "text": "Third Level Node 3-3" },
            // Level 4 (27 cards)
            { "id": "card-L4-1", "level": 4, "text": "L4 Child of L3-1 Node 1" },
            { "id": "card-L4-2", "level": 4, "text": "L4 Child of L3-1 Node 2" },
            { "id": "card-L4-3", "level": 4, "text": "L4 Child of L3-1 Node 3" },
            { "id": "card-L4-4", "level": 4, "text": "L4 Child of L3-2 Node 1" },
            { "id": "card-L4-5", "level": 4, "text": "L4 Child of L3-2 Node 2" },
            { "id": "card-L4-6", "level": 4, "text": "L4 Child of L3-2 Node 3" },
            { "id": "card-L4-7", "level": 4, "text": "L4 Child of L3-3 Node 1" },
            { "id": "card-L4-8", "level": 4, "text": "L4 Child of L3-3 Node 2" },
            { "id": "card-L4-9", "level": 4, "text": "L4 Child of L3-3 Node 3" },
            { "id": "card-L4-10", "level": 4, "text": "L4 Child of L3-4 Node 1" },
            { "id": "card-L4-11", "level": 4, "text": "L4 Child of L3-4 Node 2" },
            { "id": "card-L4-12", "level": 4, "text": "L4 Child of L3-4 Node 3" },
            { "id": "card-L4-13", "level": 4, "text": "L4 Child of L3-5 Node 1" },
            { "id": "card-L4-14", "level": 4, "text": "L4 Child of L3-5 Node 2" },
            { "id": "card-L4-15", "level": 4, "text": "L4 Child of L3-5 Node 3" },
            { "id": "card-L4-16", "level": 4, "text": "L4 Child of L3-6 Node 1" },
            { "id": "card-L4-17", "level": 4, "text": "L4 Child of L3-6 Node 2" },
            { "id": "card-L4-18", "level": 4, "text": "L4 Child of L3-6 Node 3" },
            { "id": "card-L4-19", "level": 4, "text": "L4 Child of L3-7 Node 1" },
            { "id": "card-L4-20", "level": 4, "text": "L4 Child of L3-7 Node 2" },
            { "id": "card-L4-21", "level": 4, "text": "L4 Child of L3-7 Node 3" },
            { "id": "card-L4-22", "level": 4, "text": "L4 Child of L3-8 Node 1" },
            { "id": "card-L4-23", "level": 4, "text": "L4 Child of L3-8 Node 2" },
            { "id": "card-L4-24", "level": 4, "text": "L4 Child of L3-8 Node 3" },
            { "id": "card-L4-25", "level": 4, "text": "L4 Child of L3-9 Node 1" },
            { "id": "card-L4-26", "level": 4, "text": "L4 Child of L3-9 Node 2" },
            { "id": "card-L4-27", "level": 4, "text": "L4 Child of L3-9 Node 3" }
        ];

        const gridContainer = document.getElementById('grid-container');
        const appContainer = document.getElementById('app-container');

        // Dynamically create and append cards
        cardsData.forEach(card => {
            const cardElement = document.createElement('div');
            cardElement.id = card.id;
            cardElement.classList.add('card');
            cardElement.textContent = card.text;
            gridContainer.appendChild(cardElement);
        });

        // Pan and Zoom functionality
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX, startY;
        let initialGridTransform = getComputedStyle(gridContainer).transform;

        function updateTransform() {
            gridContainer.style.transform = `${initialGridTransform} translate(${translateX}px, ${translateY}px) scale(${scale})`;
        }

        // Mouse wheel for zoom
        appContainer.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent page scrolling
            const scaleAmount = 0.1;
            const appRect = appContainer.getBoundingClientRect();
            const mouseX = e.clientX - appRect.left;
            const mouseY = e.clientY - appRect.top;

            const oldScale = scale;
            if (e.deltaY < 0) {
                scale += scaleAmount; // Zoom in
            } else {
                scale -= scaleAmount; // Zoom out
            }
            scale = Math.max(0.2, Math.min(3, scale)); // Clamp scale between 0.2 and 3

            // Adjust translation to zoom towards the mouse pointer
            // Calculate coordinates relative to the *grid container's current position and scale*
            const gridRect = gridContainer.getBoundingClientRect();
            const gridX = mouseX - gridRect.left;
            const gridY = mouseY - gridRect.top;

            translateX -= (gridX / oldScale) * (scale - oldScale);
            translateY -= (gridY / oldScale) * (scale - oldScale);

            updateTransform();
        });

        // Mouse drag for pan
        appContainer.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - translateX;
            startY = e.clientY - translateY;
            appContainer.style.cursor = 'grabbing';
        });

        appContainer.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            translateX = e.clientX - startX;
            translateY = e.clientY - startY;
            updateTransform();
        });

        appContainer.addEventListener('mouseup', () => {
            isDragging = false;
            appContainer.style.cursor = 'grab';
        });

        appContainer.addEventListener('mouseleave', () => {
            isDragging = false;
            appContainer.style.cursor = 'grab';
        });

        // Touch events for pan and zoom on mobile
        let touchStartX, touchStartY;
        let initialDistance = -1; // For pinch zoom
        let lastScale = 1;
        let initialTranslateX, initialTranslateY;

        appContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                initialTranslateX = translateX;
                initialTranslateY = translateY;
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                appContainer.style.cursor = 'grabbing';
            } else if (e.touches.length === 2) {
                // Pinch to zoom
                initialDistance = getDistance(e.touches[0], e.touches[1]);
                lastScale = scale;
                isDragging = false; // Disable single-finger pan during pinch
            }
        }, { passive: false }); // Use passive: false to allow preventDefault

        appContainer.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling on touch devices

            if (isDragging && e.touches.length === 1) {
                translateX = initialTranslateX + (e.touches[0].clientX - touchStartX);
                translateY = initialTranslateY + (e.touches[0].clientY - touchStartY);
                updateTransform();
            } else if (e.touches.length === 2 && initialDistance > 0) {
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                const newScale = lastScale * (currentDistance / initialDistance);
                
                // Calculate center point of the two touches relative to appContainer
                const appRect = appContainer.getBoundingClientRect();
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - appRect.left;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - appRect.top;

                const oldScale = scale;
                scale = Math.max(0.2, Math.min(3, newScale)); // Clamp scale

                // Adjust translation to zoom towards the center of the pinch
                // Calculate coordinates relative to the *grid container's current position and scale*
                const gridRect = gridContainer.getBoundingClientRect();
                const gridX = centerX - gridRect.left;
                const gridY = centerY - gridRect.top;

                translateX -= (gridX / oldScale) * (scale - oldScale);
                translateY -= (gridY / oldScale) * (scale - oldScale);
                updateTransform();
            }
        }, { passive: false });

        appContainer.addEventListener('touchend', () => {
            isDragging = false;
            initialDistance = -1;
            appContainer.style.cursor = 'grab';
        });

        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Initial cursor style
        appContainer.style.cursor = 'grab';
    </script>
</body>
</html>
